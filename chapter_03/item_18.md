# Item18. 상속보다는 컴포지션을 사용하라
*여기서 말하는 상속은 클래스가 다른 클래스를 확장하는 구현 상속

[메인페이지 이동](../README.md)

```
1. 메서드 호출과 달리 상속은 캡슐화를 깨뜨린다.
2. 자바빈즈 패턴
3. 빌더 패턴
```

## 1. 메서드 호출과 달리 상속은 캡슐화를 깨뜨린다.

---

> 상위 클래스가 어떻게 구현되느냐에 따라 하위 클래스의 동작에 이상이 생길 수 있다. </br>

### [소스 보기](./java//Item_18_1.java) </br></br></br>

> 해법 1) 하위클래스에서 addAll 메서드를 재정의하지 않는다. </br>

### [소스 보기](./java//Item_18_2.java) </br></br></br>

내부 구현 방식을 알아야 한다는 단점이 있음

> 해법 2) addAll 메서드를 super를 사용하지 않고 재정의 </br>

### [소스 보기](./java//Item_18_3.java) </br></br></br>

어렵고 귀찮으며 오류를 내거나 성능을 떨어뜨릴 수 있음
상위 메서드가 private 인 경우 구현 불가

## 2. 컴포지션을 사용한다.

---

> 데코레이션 패턴 </br>

### [소스 보기](./java//Item_18_4.java) </br></br></br>

> wrapper 클래스 </br>

### [소스 보기](./java//Item_18_4.java) </br></br></br>


상속 방식은 구체 클래스 각각을 따로 확장해야 하며, 지원하고 싶은 상위 클래서의 생성자 각각에 대응하는 생성자를 별도로 정의해줘야함

컴포지션 방식은 한 번만 구현해 두면 어떠한 Set 구현체라도 계측(count)할 수 있으며, 기존 생성자들과도 함께 사용 가능

## 3. wrapper 클래스는 단점이 거의 없지만 callback 프레임워크와는 어울리지 않는다.

---


### [소스 보기](./java//Item_18_5.java) </br></br></br>

## 결론

---

상속은 반드시 하위 클래스가 상위 클래스의 ‘진짜’ 하위 타입(is-a)인 상황에서만 쓰여야 한다.

왜냐하면 컴포지션을 써야 할 상황에서 상속을 사용하는 건 내부 구현을 불필요하게 노출하여 클라이언트의 잘못된 접근을 허용할 수 있고 클래스의 성능을 영원히 제한한다.

또한, 컴포지션은 상위 클래스의 결함을 숨기는 새로운 API를 설계할 수 있지만 상속은 상위 클래스의 API를 결함까지 그대로 승계한다.