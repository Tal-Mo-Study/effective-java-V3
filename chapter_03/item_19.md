# Item19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

[메인페이지 이동](../README.md)

## 1. 상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야 한다.

---

> 상위 클래스가 어떻게 구현되느냐에 따라 하위 클래스의 동작에 이상이 생길 수 있다. </br>

### [소스 보기](./java//Item_19_1.java) </br></br></br>

iterator 메서드를 재정의하면 remove 메서드의 동작에 영향을 줌을 확실히 알 수 있음
하지만, 좋은 API 문서란 ‘어떻게’가 아닌 ‘무엇’을 하는지를 설명해야 함

## 2. 효율적인 하위 클래스를 큰 어려움 없이 만들 수 있게 하려면 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅(hook)을 잘 선별하여 protected 메서드 형태로 공개해야 할 수 있다.

---

### [소스 보기](./java//Item_19_2.java) </br></br></br>

sort() 메서드가 없다면 printAll() 메서드를 처음부터 새로 구현해야 함


## 3. 상속용 클래스를 시험하는 방법은 직접 하위 클래스를 만들어보는 것이 유일하다.

---

상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증해야 함

상속용 클래스의 생성자는 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안됨

### [소스 보기](./java//Item_19_3.java) </br></br></br>


## 4. clone과 readObject 모두 직접적으로든 간접적으로든 재정의 가능 메서드를 호출해서는 안된다.

---

readObject의 경우하위 클래스의 상태가 미처 다 역직렬화되기 전에 재정의한 메서드부터 호출

clone의 경우 하위 클래서의 clone 메서드가 복제본의 상태를 수정하기 전에 재정의한 메서드를 호출하여 잘못하면 원본 객체에도 피해를 줄 수 있음

## 5. 상속용으로 설계하지 않은 클래스는 상속을 금지해라.

---

클래스를 final로 선언

모든 생성자를 private이나 package-private으로 선언하고 public 정적 메서드를 만들어줌

## 6. 구체 클래스가 표준 인터페이스를 구현하지 않아 상속을 꼭 허용해야겠다면 클래스 내부에서는 재정의 가능 메서드를 사용하지 않게하고 문서로 남겨라.
