# Item45. 스트림은 주의해서 사용하라

[메인페이지 이동](../README.md)

```
스트림을 사용해야 멋지게 처리할 수 있는 일이 있고, 반복 방식이 더 알맞은 일도 있다.
그리고 수많은 작업이 이 둘을 조합했을 때 가장 멋지게 해결된다.
스트림과 반복 중 어느 쪽이 나은지 확신하기 어렵다면 둘 다 해보고 더 나은 쪽을 택하라.
```

<br>

## 스트림 API?

---

>1. 스트림 : 데이터 원소의 유한 혹은 무한 시퀀스
>2. 파이프라인 : 원소들로 수행하는 연산 단계 표현

```
스트림의 원소들은 어디서든 올 수 있음
 ex) 컬렉션, 배열, 파일, 정규표현식 패턴 매처, 난수생성기, 다른 스트림, ...

스트림 안의 데이터 원소들은 객체 참조나 기본 타입 값
 // 기본 타입값으로 int, long, double 세 가지 지원

```

>스트림 파이프라인 : 소스 스트림 -> (중간 연산) -> 종단 연산

```
각 중간 연산은 스트림을 어떠한 방식으로 변환한다.
 ex) 각 원소에 함수를 적용, 원소 필터링, ...

중간 연산들은 모두 한 스트림을 다른 스트림으로 변환한다.
 -> 변환된 스트림의 원소 타입은 변환 전 스트림과 다를 수 있다.

종단 연산은 마지막 중간 연산이 내놓은 스트림에 최후 연산을 진행한다.
 ex) 원소 정렬해서 컬렉션에 담기, 특정 원소 하나 선택, 모든 원소 출력, ...
```

>스트림 파이프라인의 지연 평가(lazy evaluation)

```
평가는 종단 연산 호출시 이뤄짐. 종단 연산에 쓰이지 않는 데이터 원소는 계산에 쓰이지 않음
 -> 무한 스트림을 다룰 수 있게 해주는 열쇠
 -> 종단 연산 없는 스트림 파이프라인은 no-op(아무일도 안 함)과 동일하다
```

<br>

>스트림 활용
```
 - 사용하기 좋은 예시
1) 원소들의 시퀀스를 일관되게 변환
2) 원소들의 시퀀스를 필터링
3) 원소들의 시퀀스를 하나의 연산을 사용해 결합(더하기, 연결하기, 최솟값 구하기 등)
4) 원소들의 시퀀스를 컬렉션에 모으기(공통된 속성을 기준으로)
5) 원소들의 시퀀스에서 특정 조건을 만족하는 원소를 찾기

 - 사용하기 안 좋은 예시 : 코드 블록에서는 가능하지만, 람다에서는 불가능한 경우
1) 코드 블록에서는 범위 안의 지역변수를 읽고 수정할 수 있다. 하지만 람다에서는 사실상 final인 변수만 읽을 수 있고, 지역변수 수정은 불가능하다.

2) 코드 블록에서는 return / break / continue 문으로 블록의 흐름을 제어하거나, 메서드 선언에 명시된 검사 예외를 던질 수 있다. 하지만 람다는 모두 불가능하다.

 - 사용하기 어려운 경우
한 데이터가 파이프라인의 여러 단계를 통과해야할때 이 데이터의 각 단계에서의 값들에 동시에 접근해야 하는 경우
 -> 파이프라인은 일단 한 값을 다른 값에 매핑하고 나면 원래의 값은 잃는 구조

 * 기존 코드는 스트림을 사용하도록 리팩터링하되, 새 코드가 더 나아 보일 때만 반영
```


<br><br>

>Code

[Java Code Item_45](./java/Item_45)